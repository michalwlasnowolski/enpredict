import pickle
import sys
from sklearn import cross_validation
from sklearn.metrics import auc_score
from sklearn.ensemble import RandomForestClassifier
from sklearn import tree
from choose_classifier import Classifier

class Mutation():

    def prediction(self, cutter, count_kmers, predict, seq, classifier, which_database):

        
        if 'fly' in which_database:
        
            cut_seq=cutter.cutter(seq, 200, 200)
            kmers=count_kmers.count_kmers(cut_seq, 4, 200, 200)
            prediction=predict.classification(kmers, 200, classifier)
        
        elif 'fantom' in which_database:
            cut_seq=cutter.cutter(seq, 300, 300)
            kmers=count_kmers.count_kmers(cut_seq, 4, 300, 300)
            prediction=predict.classification2(kmers, 300, classifier, cut_seq)

        elif 'vista' in which_database:
            cut_seq=cutter.cutter(seq, 1500, 1500)
            kmers=count_kmers.count_kmers(cut_seq, 4, 1500, 1500)
            prediction=predict.classification2(kmers, 1500, classifier, cut_seq)
            
        return prediction[0][1]
        




    def mutation(self, start, end, seq, cutter, count_kmers, predict, classifier, which_database, candidates, dict_sequences, results_seq_pred):
        print 'wlazl'
        del(candidates[0])
        seq_list=[]
        alphabet=['T', 'A', 'G', 'C']
        sep=''
        the_lowest_list=[]
            
        #reference_result=self.prediction(cutter, count_kmers, predict, seq, classifier, which_database)
        #the_lowest=[reference_result, seq]

        print seq
        seq_len=len(seq)
        #positions_nucleo=[]
        pre_k_best=[]
        k_best=[]


        for i in seq: seq_list.append(i)

        
        for j in xrange(int(start), int(end)):
            new_seq_list=list(seq_list)
            for nucleotide in alphabet:
                if seq_list[j]==nucleotide:
                   
                    pass
                else:
                    new_seq_list[j]=nucleotide
                    new_seq=sep.join(new_seq_list)
                    new_prediction=self.prediction(cutter, count_kmers, predict, new_seq, classifier, which_database)
                    
                    pre_k_best.append([new_prediction, new_seq])

        k_best_sorted=sorted(pre_k_best)

        #print k_best_sorted

        for i in xrange(len(k_best_sorted)):

            if not k_best_sorted[i][1] in dict_sequences:
                k_best.append(k_best_sorted[i])

            if len(k_best) == 3: 
                break


        for i in xrange(len(k_best)): 

            if k_best[i][1] < 0.63: 
                results_seq_pred.append(k_best[i])
            
            else:
              candidates.append(k_best[i])
              dict_sequences[k_best[i][0]]=k_best[i][1]
            

            

                    
        return candidates, dict_sequences, results_seq_pred

    
    def best_mutation(self, start, end, seq, cutter, count_kmers, predict, which_database):


        which_classifier=Classifier()
        which_classifier_name=which_classifier.choose_classifier(which_database)
        classifier = pickle.load(open(which_classifier_name))
       
        reference_result=self.prediction(cutter, count_kmers, predict, seq, classifier, which_database)



        dict_sequences={seq:reference_result}
        candidates=[[reference_result, seq]]        
        print candidates

        results_seq_pred=[]

        while len(candidates)!=0:
            #print results_seq_pred
            candidates, dict_sequences, results_seq_pred=self.mutation(start, end, candidates[0][1], cutter, count_kmers, predict, classifier, which_database, candidates, dict_sequences, results_seq_pred)


        return results_seq_pred



