from seq_cutter import SeqCutter
from kmers2 import Kmers
from predict import Predict
from spoil4_1 import Mutation
from comparator import Comparator
from template_mutation import TemplateMutation
from choose_classifier import Classifier
import pickle
import random
from choose_classifier import Classifier
#from sets import Set

cutter=SeqCutter()
count_kmers=Kmers()
mutation=Mutation()
predict=Predict()
comparator=Comparator()
template_mutation=TemplateMutation()
which_classifier=Classifier()

sequence='TACTCAGCTGCTGATGCTGCACATAACTATGCACATACATATGAATGTACATATGTACGTTCCGTTGGAAAGAGAGATCACAACGGAGCGCCCATTCGTTGTATTCACTCTCACGTATCACACTGAACCATTGGCGTTAGTCTCATTTAGGCTTAATTGCGTAAAATTCTGATATTAAAAACATATTCATTTTAAACTCT'
#sequence='GGCGATGACTGAGTCTATATGGATACTCGCCGAAGCATATATACTCGTACTCGCATTCTTAGTACACCGCCTCAAGAATAGAACGTTTAACTGGAACTTACACATGGCTTCCCATTTCGAAATGCTCGCTTTCATTTGCGTTCGCAGCCACTTTGATGTGGTTCCCTGGCCACGGATTTCATCAACATGTGGCTCCGGCC'
#fantom
#sequence='catcaaggggcacttgcaggccagtgccaagccaccctcgtaccccctcatcttcccctcccatgctcctgctcctcagtgtccaaagtccagaaggggctgaggtggcaggggactggcatgtcagcactgcttccaatgtgtgcacacctggctgggcagtgacagcaccctgctgggtcccaaccccactctgagatcagagcacagagccaggaggtgggagagaccaggcagcaggaagaggtgcctccaagcctgcaaggggcaaggggggcgttcccaggctccccaagagtc'

#sequence=vista='ACCGCCGCGGCTTTTTGCTCCGTGCCGCTCGTTTTTGTCCCCGCCGCCGCGGCTTTTTGACCCCGCCGCCGCAGCTTTTTCCCCCAGTCGCGGGTTTTCGCCCCCACCGCAGCGATTTTCTGCCCCCGCCGCCGAGGCTTTTTGCCCCCGCCGCCACTACTTTTTGCGGCTTTTTGCCCACGCCGCCGCGGCTTTTTCCCCCACCGCCCGAGCTTTTTGCCGCCGGAGCTATCAGCCCCCGCCGCCGTGGCTTTTTCCCCCGATGCCGCGGCGTTTTGCCCCCGCCTCCGCGGTTTTTTTGTCCCCGCCGCTGAGACTTTTTGCCGCCATAGCTTTTTACCCGCGCCGCCACGGCTTTTTGTGGTTTTTTTTGCCCCCACTCCCGCTGCTTTTTGCTCCTGCCACCGCGGCTTTTTGCCCCCGCCGCGGATTTTTACCCCCGCCGCGGAGGATTTTTCCCCTGGTGCTGCGGCTCTGAGGGCAGGAGCGGCAGACTCGGCTGCTAGCTCCACTGGCGTCCTGGCAAGGGCAGCGCCGAGGGGCGCTCCTGGTCCAGCTCTCCTGGCTCGGGGGTTCTTTGCCTAGGCGCCGGCGCCCCGGGCTCCCTGCCTCGGCCTCTGTGGCCTGCATAGAGCGGCGCTGCGCGCAGAGGCGATGGGAGAGAAGAAGGAGGGTGGTGGCGGGGGTGATGCGGCATTAGCGGAAGGTGGCGCAGGGGCCGCGGGCAGCTCCAGAAGCTCATTGGCATCTTCATTGGCAGCCTTCGCTGGCTGGGCACCAAGTGCGCTGTGTCGAACGACCTCACCCAGCAGAAGATACCGACCCTGGAGGTAAGGGGTTCGGGGACCCGGGCTGGGCTCCAGGAGGAGCTCAGACACCTCCCTCGGGGCCCCAGTTCACTCCTGGCCCAGTTGCATCCTTGAGCCCGCATTGCGCCCTTGGAGTCTTCCCCTCCCTCCTGCATTCGCTGATGCGGCAGCAGGAGGACCCGGGACCAGCCCTCACCTTGAGCGCGATTTGTGGGGCGGGTGCGTGGTGGGAACTGGGATGAAGGATCCAGGGTCCTGTGGGGGGGGGTGGTGGGCTGTGCGCGGACATCCCCTTCCACCCTGAATTTCcatctggtccagccctctcatcttgtaggtgaggaaaccgaaggcctgaggaagaactgacttgccAGGAACCCCTGTTAAGGAGAATTATCAAAGTGTGGTTATTAAAGGAGAACTGAGATGGGAGTCAGACCTGGAGGCCCACACTCTTGGTTAAGACATTATACCACCTTGAGTCTGGCCTGTTTACTGAGGGTGAGCCACTCCATCCTTGTCTGATTGTGGGGTCTTGACCTCAAGGGGTTTCCTGCAGGAAGAAGCAAATGGGTTTGCTTTCCTAGCTCTGTCCAGTATCTTAGGGACCCTGAGGACTGAAGAGATTCTTGTAGAGCCATCTGGTGTATGTCATGGGTGGGCCTTTTTTGAATGTCAGTCTGCCCAT'
sequence=sequence.upper()
all_the_lowest=[]
#positions=[]
new_positions=''
cut_off=0.63
k_choice=10
random_from_best=1
how_many_results=20
frame=200
region=[]

which_classifier_name=which_classifier.choose_classifier('fly')
classifier = pickle.load(open(which_classifier_name))
results_pred_seq, reference_pred_seq=mutation.run_mutate(count_kmers, classifier, sequence, frame, k_choice, random_from_best, cut_off, how_many_results, region)
list_seq_pred_pos=comparator.compare(reference_pred_seq, results_pred_seq)

print list_seq_pred_pos

'''
#print request.POST[u'select']
sep="\t"
#print '333'
frame=200
#print sequence




def find_mutations(s):
    all=set(["A","C","G","T"])
    nucs=list(s)
    seqs=[]
    for i,nuc in enumerate(nucs):
        for mut in all-set([nuc]):

            yield ["".join(nucs[:i]+[mut]+nucs[i+1:]), '%i%s' % (i, mut)]




def mutate(count_kmers, dic, keys, classifier, all_seq, candidates, results, how_many_best, how_many_random, cut_off, frame):

    #czy  musi byc zapytanie, czy jest przynajmniej jeden??
    candidate=candidates[0]

    #print candidate
    del(candidates[0])

    seqs=[x for x in find_mutations(candidate[1])]
    for_kmers=[]
    mut_syms=[]
    #print candidate[2]
    if len(candidate[2])>1: old_muts=candidate[2].split('_')
    else: old_muts=[]
    
    for i in seqs:
        #print old_muts
        new_seq_mut="_".join(sorted(list([i[1]] + old_muts)))
        if not new_seq_mut in all_seq: 
            for_kmers.append(i[0])
            mut_syms.append(new_seq_mut)
            #print new_seq_mut
            all_seq[new_seq_mut]=''

    if len(for_kmers)!=0:
        kmers=[count_kmers.count_vec(x, dic, keys, frame) for x in for_kmers]
        predicted = [classifier.predict_proba(i)[0][1] for i in kmers]
        seq_pred=sorted(zip(predicted, for_kmers, mut_syms))[:how_many_best]
        new_candidates=random.sample(seq_pred[1:], how_many_random)+[seq_pred[0]]
    #print seq_pred
    #new_candidates=[]
    #try: new_candidates=random.sample(seq_pred[1:], how_many_random)+[seq_pred[0]]
    #except: pass #print len(new_candidates)

        for i in new_candidates:
            if i[0]<= cut_off:
                results.append(i)
            else:
                candidates=candidates+new_candidates
    
    return candidates, all_seq, results

all_seq={}

keys,dic=count_kmers.rc_kmers(count_kmers.all_kmers(4))
which_classifier=Classifier()
which_classifier_name=which_classifier.choose_classifier('fly')
classifier = pickle.load(open(which_classifier_name))
#candidates = 

results=[]
candidates = [[classifier.predict_proba(count_kmers.count_vec(sequence, dic, keys, frame))[0][1], sequence, '']]
#print candidates
#print candidates
results_cutoff=20
z=0




while len(candidates)!=0 and len(results)<results_cutoff:
    z+=1
    print z, len(candidates), len(results)
    candidates, all_seq, results=mutate(count_kmers, dic, keys, classifier, all_seq, candidates, results, 10, 1, 0.63, frame)

print results




'''
