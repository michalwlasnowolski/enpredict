#!/usr/bin/python

import re
import sys
from load_vista import load_enhancers, get_name
import load_vista
from glob import glob
import os
import time
import pickle
import matplotlib.pyplot as plt
from numpy import transpose
from lens import chr_lens
from bx.bbi.bigwig_file import BigWigFile







def make_string(fasta):
	
	sequence=''
	for i in xrange(len(fasta)):
		seq=fasta[i].strip()
		sequence+=seq
	return sequence

#sequence=make_string(s)



def if_N(seq):

	question=re.search(r'N', seq)
	return question

def cut_sequence(sequence, frame_len, step, name):

	print 'robimy cut_seq'	
	lenght_sequence=len(sequence)
	path='/home/michal/mgr/data/chr_id/%s_%s/%s.id' % (frame_len, step, name)
 	#output = open('/home/michal/mgr/data/chr_id/%s_%s/'+name+'.id', "w") % (frame_len, step)
	output = open(path, 'w')
	num_frames=lenght_sequence/frame_len
	for i in xrange(num_frames*2):
		
		position_start=i*step

		ile_zostalo=lenght_sequence-position_start

		if ile_zostalo>=frame_len:

			position_end=position_start+(frame_len-1)
			if not if_N(sequence[position_start:position_end]):
					
				output.write(">"+name+":%d-%d:%d\n%s\n" %  (position_start, position_end,i,sequence[position_start:position_end]))
			#print 'jest to ramka %d z %d' % (i, num_frames)
		else:
			
			position_end=len(sequence)
			if not if_N(sequence[position_start:position_end]):
				output.write(">"+name+":%d-%d:%d\n%s" %  (position_start, position_end,i,sequence[position_start:position_end]))
	output.close()

	

#cut_sequence(sequence, frame_lenght, step)

	



#print result
#print len(sequence)


def complement(x):
    if x == 'A': return 'T'
    elif x == 'C': return 'G'
    elif x == 'G': return 'C'
    elif x == 'T': return 'A'
    else: 
        #print x
        return x

def is_compl(x, y):
    if len(x) != len(y):
        return False
    for i in xrange(len(x)):
        if complement(x[i]) != y[-i-1]: 
            return False
    return True

def get_compl(x): 
    y = ''
    for a in x:
        y = complement(a) + y
    return y


def gen_all(k):
    d = ['']
    alph = ['A', 'C', 'G', 'T']
    for i in xrange(k):
        new_d = []
        for s in d:
            for a in alph:
                new_d.append(s+a)
        d = new_d
   # print len(d)
    #filtrowanie
    final = []
    for seq in d:
        to_add=True
        for seq2 in final:
            if is_compl(seq, seq2):
                to_add = False
                break
        if to_add:
            final.append(seq)
    #print final
    #print len(final)
    return final


#d=gen_all(4)



def count_kmers(enhancers_file, k, frame_len, step):
    #if os.path.exists(bigwig_file + ".means"):
    #    return
    #print "KMERY", k
    keys = gen_all(k) 
    #enhancers=load_enhancers_with_seq(enhancers_file)
    path_output= '/home/michal/mgr/data/chr_id_4mers/%s_%s/%s.%dmers' % (frame_len, step,enhancers_file, k)
    #output = open('/home/michal/mgr/data/chr_id_4mers/%s_%s/'+enhancers_file+'.%dmers' % k, "w") % (frame_len, step)
    output = open(path_output, 'w')
    for x in keys:
        output.write("\t%s" %x)
    output.write('\n')
    z=0 
    #for enh in enhancers:
    path_input='/home/michal/mgr/data/chr_id/%s_%s/%s' % (frame_len, step, enhancers_file)
    #enhancers_file=open('/home/michal/mgr/data/chr_id/%s_%s/'+enhancers_file).readlines() % (frame_len, step)
    enhancers_file=open(path_input).readlines() 
    enh_lenght=len(enhancers_file)
    print 'liczymy kmery'
    for i in xrange(enh_lenght):
	id_seq=''
	sequence=''	
	 #if i%1000:
	#	print i*1000
	#print "ramka nr %d z %d" % (z, enh_lenght)
	z+=1	
	
	if enhancers_file[i][0]=='>':
	    id_seq=enhancers_file[i].strip()
	    output.write("%s\t" % id_seq)
	else:
	    sequence=enhancers_file[i].strip()
	    sequence_len=len(sequence)
	    kmers = dict.fromkeys(keys, 0)
       	    for i in xrange(0, sequence_len - k):

	    
                s = str(sequence[i:(i+k)].upper())
                if kmers.has_key(s):
                    kmers[s]+=1
                elif kmers.has_key(get_compl(s)):
                    kmers[get_compl(s)] += 1
                else:
                    print id_seq, s
                #return
            if sequence_len == 0:
                print "no sequence for ", id_seq
            else:
                for key in keys:
                    output.write("%f\t" % (float(kmers[key])/sequence_len))
		    #line="%f\t" % (float(kmers[key])/sequence_len)
		    #print line
		    #print output
            output.write('\n')
    output.close()

#count_kmers(name+".id", 4)



def load_frames(file_id):

	frames = open(file_id).readlines()
	list_seq=[]
	list_adnotation=[]
	frames_len=len(frames)

	print 'ladujemy ramki'
	for i in xrange(frames_len):
		if frames[i][0] != '>':
			list_seq.append(frames[i].strip())
			#print frames[i].strip()
		else:
			adnotation=frames[i].split(':')
			adnotation=adnotation[1].split('-')
			list_adnotation.append(adnotation[0])
			#print adnotation[0]
		#print ("load_frames %d z %d") % (i, frames_len)

	return list_seq, list_adnotation


#list_seq, list_adnotation = load_frames('/home/michal/mgr/data/chr_id/600_300/chr24.fa.id')
#print list_seq, list_adnotation



def count_chrom_mean(bigwig):
    mean_all = {}

    #f=open(bigwig, "r")
    #bw=BigWigFile(file=f)

    #summary = bw.summarize('chr22', 1)
    
    #mean_all['chr22'] = summary.sum_data / summary.valid_count 

    for (chrom, length) in chr_lens.items():
        #if chrom != 'chrY':
        summary = bigwig.summarize(chrom, 1, length, 1)
        
        mean_all[chrom] = summary.sum_data / summary.valid_count 
    return mean_all


#print count_chrom_mean('wgEncodeBroadHistoneH1hescH3k4me3StdAln_2Reps.norm5.rawsignal.bw')

def count_mean_signal(enhancers, bigwig_file, name, frame_lenght, step, modif_name, group_modif):
    print "processing", bigwig_file
    #if os.path.exists(bigwig_file + ".means"):
    #    return
    #output = StringIO.StringIO()
    #bigwig_file='/home/michal/mgr/data/CHIP_Seq/Gm12878/Gm12878H3k9ac.bw'
    f = open(bigwig_file, "r") 
    bigwig = BigWigFile(file=f)
    #print bigwig.type()
#    fails = open("%s.fails.%s" %(bigwig_file, name), "w")
    print bigwig_file
    mean_all = count_chrom_mean(bigwig)
    start_clock = time.clock()
    

    name_for_summary=name
    if name == 'chr23': name_for_summary='chrX'

    output2_path='/home/michal/mgr/data/means/%s/%s/%s_%s/' % (group_modif, modif_name[:-3],frame_lenght, step)
    if not os.path.exists(output2_path):
        os.makedirs(output2_path)
    
    fails_path=output2_path+'fails/'
    if not os.path.exists(fails_path):
	os.makedirs(fails_path)

    output2_file='%s.means.%s_%s_%s' % (modif_name[:-3], name, frame_lenght, step)
    #output2 = open('/home/michal/mgr/data/means/H1hescH3k27me3S/300_150/H1hescH3k27me3S' + ".means." + name, "w")
    output2=open(output2_path+output2_file, 'w')
   
    fails = open(fails_path+output2_file+".fails", "w")
    print output2_path, output2_file 
    for i in xrange(len(enhancers)):
	start=int(enhancers[i])
	end=int(enhancers[i])+step
        summary = bigwig.summarize(name_for_summary, start, end, 1)
        
	if summary.valid_count*10 < end-start:
            mean = mean_all[name_for_summary]
            fails.write("%d\t%d\n" % (start, summary.valid_count))
        else:
            mean = summary.sum_data / summary.valid_count
        output2.write("%d\t%f\n" % (start, mean))
	#print start, mean
    #bigwig.close()
    
    output2.write(output.getvalue())
    #output.close()
    output2.close()
    #os.remove(bigwig_file + ".means.tmp")
    
    #print "output written to: %s.means.%s" % (bigwig_file, name)

    end_clock = time.clock()
    print "time: %.2gs" % (end_clock-start_clock)




def count_all_means(enhancers_file, directories, name):
    enhancers = load_enhancers(enhancers_file)
    print len(enhancers)
    for directory in directories:
        for filename in glob(directory + "/*.bigWig"):
            count_mean_signal(enhancers, filename, name)
        for filename in glob(directory + "/*.bw"):
            count_mean_signal(enhancers, filename, name)


#lista folderow z danymi .list
#True
#plik kmerami
#rameczki z kmers
#

def read_data(filename, isFile, kmers_filename , frames, name, frame_lenght, step_len):
    knames = []
    directories = []
    filenames = []
    if kmers_filename == '':
        useKmers = False
    else:
        useKmers = True
        kmers = open(kmers_filename)
        knames = kmers.readline().split('\t')[1:]
    if filename != '':
      if isFile:
        with open(filename) as f:
            for line in f.readlines():
                directories.append(line.strip())
      else:
        directories = [filename]

      for directory in directories:

	groups_modif=sorted(glob(directory+'/*'))
        for modif in groups_modif:
          frame_step='/%s_%s' % (frame_lenght, step_len)
          filenames += glob(modif + frame_step+"/*.means." + name)
	  #print modif+frame_step, name
	#print filenames
    names = filenames + knames + ["lengths", "GC-content"]
    data = {}
    #data = numpy.zeros(shape=len(enhancers), dtype={'names': names, 'formats': ['float']*len(names)})
    if filename != '':
        for filename in filenames:
            with open(filename) as f:
                row = []
                for line in f.readlines():
                    row.append(line.split()[1])
                k = load_vista.get_name(filename)
		if k in data: k=k+'bis'
		print k
                data[k] = row
    #data = array(transpose(data))
      
     
    if useKmers:
        data2 = []
        line = kmers.readline()
        while line:
            data2.append(line.split()[1:])
            line = kmers.readline()
	knames_len=len(knames)
        print 'robimy knames'
	for i in xrange(knames_len):
            data[knames[i]] = [x[i] for x in data2]
	    #print "robimy knames %d z %d" % (i, knames_len)
    #print data.shape
    
    lengths = []
    gc = []
    frames_len=len(frames)
    print 'czas na gc-content'
    for i in xrange(frames_len):
	if len(frames[i]) > 0:
	    gc.append(float(frames[i].count("G") + frames[i].count("C") + frames[i].count("g") + frames[i].count("c"))/len(frames[i]))
	else:
	    gc.append(0.5)
	#print "gc robi %d z %d" % (i, frames_len)
    data["GC-content"] = gc

    return data


def classification(name, classifier_name, frame_lenght, step_len, frames, list_adnotation, with_histmod, lists_file):

	#classifier = pickle.load(open('fantom_pickle.both__.4mers.short'))
	#classifier_name='pickle.heart__.4mers'
	
	database_name=['fantom', 'vista']
	which_database=''

	if classifier_name[0:6] == 'fantom':
		 which_database=database_name[0]
	else:
		which_database=database_name[1]


	#lista folderow z danymi .list
	#True
	#plik kmerami
	#rameczki z kmers
	#

	classifier = pickle.load(open('/home/michal/mgr/data/pickle/'+classifier_name))

	#print step_len, frames
	path_data_kmers='/home/michal/mgr/data/chr_id_4mers/%s_%s/%s.id.4mers' % (frame_lenght, step_len, name)
	if with_histmod == False:
		data=read_data('',True,path_data_kmers, frames,'', frame_lenght, step_len )
	else:
		path_lists='/home/michal/mgr/data/lists/%s' % lists_file
		name_file_means='%s_%s_%s' % (name[:-3], frame_lenght, step_len)
		data=read_data(path_lists, True, path_data_kmers, frames, name_file_means, frame_lenght, step_len)

	#print data
	print "teraz transpose"
	data = transpose([data[x] for x in sorted(data)])
	#print data

	print "teraz predict"
	predicted = classifier.predict_proba(data)

	list_predicted=[]

	predicted_len=len(predicted)
	for i in xrange(predicted_len):
		list_predicted.append(float(predicted[i][1]))
		#print "teraz tworzenie listy predykcji %d z %d" % (i, predicted_len)
	
	name=name[:-3]
	directory_classifier='/home/michal/mgr/data/wig/%s' % classifier_name
	directory_wig='/home/michal/mgr/data/wig/test/%s/%s_%s/' % (classifier_name, frame_lenght, step_len)
#	if not os.path.exists(directory_classifier):
#		os.makedirs(directory_classifier)

	if not os.path.exists(directory_wig):
		os.makedirs(directory_wig)

	path_results='/home/michal/mgr/data/wig/test/%s/%s_%s/%s_%s_%s_%s.wig' % (classifier_name, frame_lenght, step_len, name, frame_lenght, step_len, which_database)
	#results=open('heart_vista/300_150/'+name+'_vista.wig', 'w')
	results=open(path_results, 'w')

	results.write(('track type=wiggle_0 name="%s" description="enhancers prediction"  visibility=full autoScale=off vieLimits=0.0:1.0 color=50,150,255 yLineMark=11.76 yLineOnOff=on priority=10\nvariableStep chrom=%s span=%i\n') % (name, name, step_len))

	position_and_values=zip(list_adnotation, list_predicted) 

	list_predicted_len=len(list_predicted)
	print 'czas na wiggle'
	for i in xrange(list_predicted_len):
	
		results.write(('%s %f\n') % (position_and_values[i][0], position_and_values[i][1]))
		print "pisze wiggle'a %d z %d" % (i, list_predicted_len)





def main():


	frame_lenght=int(sys.argv[1])
	step=int(sys.argv[2])
	chromosome_n=sys.argv[3]
	pickle_name=sys.argv[4]
	lists_file=sys.argv[5]	

#plik=open(sys.argv[1]).readlines()

#s=plik[1:]

#name=str(sys.argv[1])


	name="chr%s.fa" % (chromosome_n)
		
		#os.system("wget --timestamping 'ftp://hgdownload.cse.ucsc.edu/goldenPath/hg19/chromosomes/"+name+".gz' -O "+name+".gz") 
		#os.system("gunzip "+name+".gz")
		
	#seq_file=open('/home/michal/mgr/data/chr/'+name).readlines()
	#s=seq_file[1:]
	print name

	#sequence=make_string(s)
		
	#cut_sequence(sequence, frame_lenght, step, name)

	#count_kmers(name+".id", 4, frame_lenght, step)
	name_small="chr%s" % (chromosome_n)
	path='/home/michal/mgr/data/chr_id/%s_%s/%s.id' % (frame_lenght, step, name)	
	frames, list_adnotation=load_frames(path)
	#group_modif='Cd20ro01778bis'
	#bigwig_file_path='/home/michal/mgr/data/CHIP_Seq/Cd20ro01778bis/'
	#bigwig_file_path=''
	#print 'UWAGA'+bigwig_file_path+pickle_name
	#count_mean_signal(list_adnotation,bigwig_file_path+pickle_name, name_small, frame_lenght, step, pickle_name, group_modif)
	
	classifier_name=pickle_name
	with_histmod=False
	classification(name, classifier_name, frame_lenght, step, frames, list_adnotation, with_histmod, lists_file)
main()

